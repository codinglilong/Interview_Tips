# 精选

## 浏览器缓存

### 强缓存

不会向服务器发送请求，主要以客户端来判断，直接从Memory Cache或者从Disk Cache 中拿，请求返回状态为200。强缓存通过HTTP header来设置。强缓存分为两种

1. Expires

   HTTP1.0的产物，它的值是一个具体的时间值，表示资源会在这个时间值之后过期。

   缺点：受限于本地时间，如果修改了本地时间，会造成缓存失效。

2. Cache-Control

   在HTTP1.1的版本中，通过指定指令来实现缓存机制，可以设置多少秒后过期，一般设置`Cache-control:max-age=秒`，Cache-control有多个缓存指令可以一起配合使用。

Cache-Control会优先于Expires。Expires现阶段为了向下兼容其他低版本浏览器

强缓存的缺点：强缓存判断是否超出某个时间或者某个时间段，而不关心服务端文件是否有更新，这个导致加载的文件可能不是服务器最新的内容，这时候需要协商缓存。

### 协商缓存

协商缓存会在强缓存失效后（比如强制刷新浏览器）浏览器携带标识向服务器请求，由服务器根据协商缓存标识决定是否使用缓存。强缓存分为两种

1. Last-Modified和If-Modified-Since

   浏览器第一次请求资源，服务器返回的同时响应头中添加Last-Modified 字段，它的值表示这个资源在服务器最后的修改时间。浏览器下一次请求检查到Last-Modified这个字段，浏览器会添加If-Modified-Since这个字段，它的值就是Last-Modified中的时间值。服务器收到这个资源请求会根据传过来的If-Modified-Since的值于服务器中这个资源的最后修改时间对比，如果没有变化返回304和空的响应体。如果If-Modified-Since的值小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200的状态。

   缺点：如果打开本地缓存的文件，即使没有对文件做修改，Last-Modified的值也会改变，服务器 不能命中导致发送相同的资源。

2. ETag表示将字符串

   ETag是由服务器为每个资源生成的唯一标识字符串，这个标识字符串是基于文件内容编码，只要文件不同，他们对应的ETag就不同

   浏览器在下一次向服务器发送请求，会将上一次返回的ETag值放到请求头里的If-None-Match字段中，服务器对比客服端传来的If-None-Match跟自己服务器上该资源的ETag是否一致。如果不匹配那么正常去请求返回200和新的ETag发送客户端。如果ETag一致，则返回304给客户端直接使用本地缓存即可

   ETag会优先于Last-Modified命中



## HTTP请求响应的内容有哪些？

### 请求

1. 请求行 例如: POST https://www.baidu.com HTTP1.1
   + 请求方法（GET、POST、HEAD、PUT、DELETE、OPTIONS、PATCH）
   + 请求URL
   + HTTP协议版本
2. 请求头 就是Chorme中的Request Header中的键值对
   + User-Agent:浏览器类型
   + Accept:客户端可识别的内容类型列表
   + Host:主机地址
   + Content-Type
   + Cookie 
   + ...
3. 请求主体 (一些请求参数，form data 等等)

### 响应

1. 响应行。包含协议/版本，响应的状态码,对响应状态码的描述
2. 响应头。与请求头一样
3. 响应主体。和网页右键“查看源码”看到的内容一样



## 常见的HTTP状态码

+ 1xx:指示信息，表示请求已接收，继续处理
+ 2xx:成功，表示请求已被成功接受
  + 200：客户端请求成功.
  + 206：客户端发送一个带有Range头的Get请求，服务器完成了
+ 3xx：服务器虽然也处理了你的请求，但客户端还需要进一步的工作，才可以完成请求
  + 301：永久性重定向，表示资源已被分配了新的 URL
  + 302：临时性重定向，表示资源临时被分配了新的 URL
  + 304：表示服务器校验后发现资源没有改变，提醒客户端直接走缓存来取资源
+ 4xx：客户端错误，请求有语法错误或者请求无法实现
  + 400：请求报文存在语法错误
  + 401：请求未经授权
  + 403：被请求页面的访问被禁止
  + 404：请求资源不存在
  + 405：资源被禁止，不允许使用请求行中所指定的方法
+ 5xx：服务端错误，服务器未能实现合法的请求
  + 500 服务器发生不可预期的错误，原来缓存的文档还可以继续使用
  + 502：网关错误
  + 503 请求未完成，服务器临时过载或宕机，一段时间后可能恢复正常
  + 504：网关超时



## HTTP2.0有哪些新特性

### 二进制分帧

在 HTTP1.x 中，数据以文本的格式进行传输，解析起来比较低效。

HTTP2.0 在传输消息时，首先会将消息划分为更小的消息和帧，然后再对其采取二进制格式的编码，确保高效的解析。

### 头部压缩

HTTP2.0 中，客户端和服务器分别会维护一份相同的静态字典，这个字典用来存储常见的头部名称，以及常见的头部名称和值的组合。同时还会维护一份相同的动态字典，这个字典可以实时被更新。

如此一来，第一次相互通信过后，后面的请求只需要发送与前面请求之间头部不同的地方，其它的头部信息都可以从字典中获取。相对于 HTTP1.x 中每次都要携带整个头部跑来跑去的笨重操作来说，大大节省了网络开销。

### 服务端推送

在 HTTP1.x 中，如果用户请求了资源 A，结果发现自己如果要用资源 A，那么必须依赖资源 B，这时他不得不再消耗一个请求。

而 HTTP2.0 中，允许服务器主动向客户端 push 资源。也就是说当服务器发现客户端请求了资源 A，却忘了请求资源 A 依赖的资源 B 时，它可以主动将资源 B 顺手推送给客户端。

这样一来，当客户端发现自己漏掉一个必要请求的时候，直接从缓存中就可以读到资源 B 了，而不必再消耗一个请求。

### 多路复用

在 HTTP 2.0 中，一次连接建立后，只要这个连接还在，那么客户端就可以在一个链接中批量发起多个请求。同时，请求与请求间完全不阻塞，A 请求的响应就算没回来，也不影响 B 请求收到自己的响应。请求与请求间做到了高度的独立，真正实现了并行请求。由此，彻底规避了队头阻塞问题。



## React 生命周期

### React 15以下的生命周期

实例化：

1. `constructor`
2. `componentWillMount`
3. `render`
4. `componentDidMount`


`props` 或者 `states`状态发生改变:

1. `componentWillReceiveProps` 如果是states状态发生改变是不会触发这个生命周期
2. `shouldComponentUpdate(nextProps,nextState)` 如果是true会有后续生命周期，如果false就没有后续了
3. `componentWillUpdate`
4. `render`
5. `componentDidUpdate`

卸载

1. `componentWillUnmount`

### React 16版本的class组件生命周期

实例化：

1. `constructor`
2. `static getDerivedStateFromProps(nextProps,prevState)`
3. `render`
4. `componentDidMount`

更新时：

1. `static getDerivedStateFromProps(nextProps,prevState)`

   一个静态函数，静态函数中不能使用this访问到class

   当父组件和自己本身状态改变时：

   `nextProps`:最新的父组件传过来的`props`
   `prevState`:当前自己组件最新的的`state`
     返回一个对象来更新 `state` 或者返回 `null` 来表示接收到的 `props` 没有变化，不需要更新 `state`

2. `shouldComponentUpdate(nextProps, nextState)`

   当父组件状态变更时：

   `nextProps`:最新的父组件传过来的`props`,当前的`this.props`是上一次的`props`

   `nextState`:当前最新的`state`,当前的`this.state`是最新的`state`

   当自己组件状态变更时：

   `nextProps`:最新的父组件传过来的`props`,当前的`this.props`最新的父组件传过来的`props`

   `nextState`:当前最新的`state`,当前的`this.state`是上一次的`state`

   如果是true会有后续生命周期，如果false就没有后续了    

3. `render`

4. `getSnapshotBeforeUpdate(prevProps, prevState)`

   当父组件状态变更时：

   `prevProps`:最新的父组件上一次传过来的`props`,当前的`this.props`是最新的`props`

   `prevState`:当前最新的`state`,当前的`this.state`是最新的`state`

   当自己组件状态变更时：

   `prevProps`:最新的父组件传过来的`props`,当前的`this.props`最新的父组件传过来的`props`

   `prevState`:是上一次的`state`,当前的`this.state`是最新`state`

   接收父组件传递过来的 props 和组件之前的状态,此方法必须有返回值，返回值作为第三个参数传递给`componentDidUpdate`，必须和 `componentDidUpdate` 一起使用，否则会报错

5. `componentDidUpdate`(prevProps, prevState, xx)

   基本上同`getSnapshotBeforeUpdate`一致，第三个可选参数是`getSnapshotBeforeUpdate`返回的值

卸载

1. `componentWillUnmount()`



## React diff算法

当对比两棵树不同时，使用逐层对比。diff算法会优先比较两棵树的根节点，如果他们的类型不同，比如之前的是div，现在变成p标签，那么就认为这两颗树完全不同，这是两个完全不同的组件。因此也没有必要再往下对比，直接把div删掉，重建为p。也就是卸载旧组件挂载新组件。

若根节点相同，在保留这个组件的基础上，检查其属性的变化，然后根据属性变化的情况去更新组件。

处理完根节点这个层次的对比，React会继承调到下个层次去对比子节点们。子节点的对比思路和根节点是一致的。

如果是同一层次的一组子节点，他们可以通过唯一的id进行区分，也就是key



## React fiber了解

## React性能优化

## MVC的理解

## 从输入URL到渲染出整个页面的过程包括三个部分

## 根据从输入URL到渲染出整个页面的过程做出性能优化

## 对闭包的理解

## 对原型链的理解

## commonjs模块和es6 module区别

## Event Loop

## Node和浏览器的Event Loop的区别

## 浏览器渲染过程

## this指向

## 对设计模式的理解

## 箭头函数与普通函数有什么不同

## 对于闭包的理解

## for in 和for of的区别

## 对前端工程的理解

前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从**模块化**、**组件化**、**规范化**、**自动化**四个方面思考。

https://www.jianshu.com/p/88ed70476adb

https://www.jianshu.com/p/0c0ea944a60a

https://www.cnblogs.com/onebox/p/9570518.html

详细见

