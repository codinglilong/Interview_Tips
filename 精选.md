# 精选

## 浏览器缓存

### 强缓存

不会向服务器发送请求，主要以客户端来判断，直接从Memory Cache或者从Disk Cache 中拿，请求返回状态为200。强缓存通过HTTP header来设置。强缓存分为两种

1. Expires

   HTTP1.0的产物，它的值是一个具体的时间值，表示资源会在这个时间值之后过期。

   缺点：受限于本地时间，如果修改了本地时间，会造成缓存失效。

2. Cache-Control

   在HTTP1.1的版本中，通过指定指令来实现缓存机制，可以设置多少秒后过期，一般设置`Cache-control:max-age=秒`，Cache-control有多个缓存指令可以一起配合使用。

Cache-Control会优先于Expires。Expires现阶段为了向下兼容其他低版本浏览器

强缓存的缺点：强缓存判断是否超出某个时间或者某个时间段，而不关心服务端文件是否有更新，这个导致加载的文件可能不是服务器最新的内容，这时候需要协商缓存。

### 协商缓存

协商缓存会在强缓存失效后（比如强制刷新浏览器）浏览器携带标识向服务器请求，由服务器根据协商缓存标识决定是否使用缓存。强缓存分为两种

1. Last-Modified和If-Modified-Since

   浏览器第一次请求资源，服务器返回的同时响应头中添加Last-Modified 字段，它的值表示这个资源在服务器最后的修改时间。浏览器下一次请求检查到Last-Modified这个字段，浏览器会添加If-Modified-Since这个字段，它的值就是Last-Modified中的时间值。服务器收到这个资源请求会根据传过来的If-Modified-Since的值于服务器中这个资源的最后修改时间对比，如果没有变化返回304和空的响应体。如果If-Modified-Since的值小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200的状态。

   缺点：如果打开本地缓存的文件，即使没有对文件做修改，Last-Modified的值也会改变，服务器 不能命中导致发送相同的资源。

2. ETag表示将字符串

   ETag是由服务器为每个资源生成的唯一标识字符串，这个标识字符串是基于文件内容编码，只要文件不同，他们对应的ETag就不同

   浏览器在下一次向服务器发送请求，会将上一次返回的ETag值放到请求头里的If-None-Match字段中，服务器对比客服端传来的If-None-Match跟自己服务器上该资源的ETag是否一致。如果不匹配那么正常去请求返回200和新的ETag发送客户端。如果ETag一致，则返回304给客户端直接使用本地缓存即可

   ETag会优先于Last-Modified命中



## HTTP请求响应的内容有哪些？

### 请求

1. 请求行 例如: POST https://www.baidu.com HTTP1.1
   + 请求方法（GET、POST、HEAD、PUT、DELETE、OPTIONS、PATCH）
   + 请求URL
   + HTTP协议版本
2. 请求头 就是Chorme中的Request Header中的键值对
   + User-Agent:浏览器类型
   + Accept:客户端可识别的内容类型列表
   + Host:主机地址
   + Content-Type
   + Cookie 
   + ...
3. 请求主体 (一些请求参数，form data 等等)

### 响应

1. 响应行。包含协议/版本，响应的状态码,对响应状态码的描述
2. 响应头。与请求头一样
3. 响应主体。和网页右键“查看源码”看到的内容一样



## 常见的HTTP状态码

+ 1xx:指示信息，表示请求已接收，继续处理
+ 2xx:成功，表示请求已被成功接受
  + 200：客户端请求成功.
  + 206：客户端发送一个带有Range头的Get请求，服务器完成了
+ 3xx：服务器虽然也处理了你的请求，但客户端还需要进一步的工作，才可以完成请求
  + 301：永久性重定向，表示资源已被分配了新的 URL
  + 302：临时性重定向，表示资源临时被分配了新的 URL
  + 304：表示服务器校验后发现资源没有改变，提醒客户端直接走缓存来取资源
+ 4xx：客户端错误，请求有语法错误或者请求无法实现
  + 400：请求报文存在语法错误
  + 401：请求未经授权
  + 403：被请求页面的访问被禁止
  + 404：请求资源不存在
  + 405：资源被禁止，不允许使用请求行中所指定的方法
+ 5xx：服务端错误，服务器未能实现合法的请求
  + 500 服务器发生不可预期的错误，原来缓存的文档还可以继续使用
  + 502：网关错误
  + 503 请求未完成，服务器临时过载或宕机，一段时间后可能恢复正常
  + 504：网关超时



## HTTP2.0有哪些新特性

### 二进制分帧

在 HTTP1.x 中，数据以文本的格式进行传输，解析起来比较低效。

HTTP2.0 在传输消息时，首先会将消息划分为更小的消息和帧，然后再对其采取二进制格式的编码，确保高效的解析。

### 头部压缩

HTTP2.0 中，客户端和服务器分别会维护一份相同的静态字典，这个字典用来存储常见的头部名称，以及常见的头部名称和值的组合。同时还会维护一份相同的动态字典，这个字典可以实时被更新。

如此一来，第一次相互通信过后，后面的请求只需要发送与前面请求之间头部不同的地方，其它的头部信息都可以从字典中获取。相对于 HTTP1.x 中每次都要携带整个头部跑来跑去的笨重操作来说，大大节省了网络开销。

### 服务端推送

在 HTTP1.x 中，如果用户请求了资源 A，结果发现自己如果要用资源 A，那么必须依赖资源 B，这时他不得不再消耗一个请求。

而 HTTP2.0 中，允许服务器主动向客户端 push 资源。也就是说当服务器发现客户端请求了资源 A，却忘了请求资源 A 依赖的资源 B 时，它可以主动将资源 B 顺手推送给客户端。

这样一来，当客户端发现自己漏掉一个必要请求的时候，直接从缓存中就可以读到资源 B 了，而不必再消耗一个请求。

### 多路复用

在 HTTP 2.0 中，一次连接建立后，只要这个连接还在，那么客户端就可以在一个链接中批量发起多个请求。同时，请求与请求间完全不阻塞，A 请求的响应就算没回来，也不影响 B 请求收到自己的响应。请求与请求间做到了高度的独立，真正实现了并行请求。由此，彻底规避了队头阻塞问题。



## React 生命周期

### React 15以下的生命周期

实例化：

1. `constructor`
2. `componentWillMount`
3. `render`
4. `componentDidMount`


`props` 或者 `states`状态发生改变:

1. `componentWillReceiveProps` 如果是states状态发生改变是不会触发这个生命周期
2. `shouldComponentUpdate(nextProps,nextState)` 如果是true会有后续生命周期，如果false就没有后续了
3. `componentWillUpdate`
4. `render`
5. `componentDidUpdate`

卸载

1. `componentWillUnmount`

### React 16版本的class组件生命周期

实例化：

1. `constructor`
2. `static getDerivedStateFromProps(nextProps,prevState)`
3. `render`
4. `componentDidMount`

更新时：

1. `static getDerivedStateFromProps(nextProps,prevState)`

   一个静态函数，静态函数中不能使用this访问到class

   当父组件和自己本身状态改变时：

   `nextProps`:最新的父组件传过来的`props`
   `prevState`:当前自己组件最新的的`state`
     返回一个对象来更新 `state` 或者返回 `null` 来表示接收到的 `props` 没有变化，不需要更新 `state`

2. `shouldComponentUpdate(nextProps, nextState)`

   当父组件状态变更时：

   `nextProps`:最新的父组件传过来的`props`,当前的`this.props`是上一次的`props`

   `nextState`:当前最新的`state`,当前的`this.state`是最新的`state`

   当自己组件状态变更时：

   `nextProps`:最新的父组件传过来的`props`,当前的`this.props`最新的父组件传过来的`props`

   `nextState`:当前最新的`state`,当前的`this.state`是上一次的`state`

   如果是true会有后续生命周期，如果false就没有后续了    

3. `render`

4. `getSnapshotBeforeUpdate(prevProps, prevState)`

   当父组件状态变更时：

   `prevProps`:最新的父组件上一次传过来的`props`,当前的`this.props`是最新的`props`

   `prevState`:当前最新的`state`,当前的`this.state`是最新的`state`

   当自己组件状态变更时：

   `prevProps`:最新的父组件传过来的`props`,当前的`this.props`最新的父组件传过来的`props`

   `prevState`:是上一次的`state`,当前的`this.state`是最新`state`

   接收父组件传递过来的 props 和组件之前的状态,此方法必须有返回值，返回值作为第三个参数传递给`componentDidUpdate`，必须和 `componentDidUpdate` 一起使用，否则会报错

5. `componentDidUpdate`(prevProps, prevState, xx)

   基本上同`getSnapshotBeforeUpdate`一致，第三个可选参数是`getSnapshotBeforeUpdate`返回的值

卸载

1. `componentWillUnmount()`



## React diff算法

当对比两棵树不同时，使用逐层对比。diff算法会优先比较两棵树的根节点，如果他们的类型不同，比如之前的是div，现在变成p标签，那么就认为这两颗树完全不同，这是两个完全不同的组件。因此也没有必要再往下对比，直接把div删掉，重建为p。也就是卸载旧组件挂载新组件。

若根节点相同，在保留这个组件的基础上，检查其属性的变化，然后根据属性变化的情况去更新组件。

处理完根节点这个层次的对比，React会继承调到下个层次去对比子节点们。子节点的对比思路和根节点是一致的。

如果是同一层次的一组子节点，他们可以通过唯一的id进行区分，也就是key



## React fiber了解

> Fiber 是React16引入的一种新的调和引擎

### Fiber解决了什么问题

在Fiber架构前，当React决定要加载或者更新组件树时，会有一个大的动作。

这个动作包括声明周期的调用、diff过程的计算、DOM树的更新等等。这个动作很大，耗时很长，而且是同步进行的，一旦开始就不能中断。这意味这你的组件挂载或者更新结束前，什么都不能去做。

如果更新一个组件需要1毫秒，如果需要更新1000个组件，就会耗时1秒，在这1秒更新的过程中，主线程都在专心运行更新操作。浏览器绘制屏幕一般来说这个频率是每秒60次。也就说每16毫秒渲染1帧。如果执行js的时间过长超过16毫秒之后用户能察觉到页面卡顿，导致页面体验下降。

因为js单线程的特点，每个同步任务不能耗时太久，不然就会让程序不会对其他输入做出反应。React以前更新过程中就会出现上述情况，而现在React Fiber就要改变现状。

### Fiber思想

面对单个任务耗时过长这个问题，把一个庞大的任务分成N多个微笑的任务，这些个小任务就是一个fiber单元。每个fiber单元每次执行超过一定的时间意味着该任务需要暂停一下让出主线程。这个暂停一下意义重大，React会在这段时间里查找有没有优先级更高的事情需要处理。以此确保主线程总在做它当下最应该做的事情。

### Fiber与生命周期

React在渲染之前会有两个工作阶段：

**render/reconcilition:调和阶段。**这个阶段就是diff过程。这个过程里，React在内存中做计算，不涉及真实DOM操作，也就是说你打断执执行、重复执行、用户都是不感知的。最后确认所有的更新行为。由于"切片"和“暂停”两个关键特性的实现，调和过程变成了一个可以被打断暂停的过程，查看优先级更高的任务并执行。有一下声明周期可以被打断：

1. getDerivedStateFromProps
2. shouldComponentUpdate
3. render

**commit**:执行调和阶段的计算结果，真正地去更新DOM，这个过程不允许被打断。会一直执行下去，这个过程涉及的生命周期有：

1. getSnapshotBeforeUpdate
2. componentDidMount
3. componentDidUpdate
4. componentWillUnmount



## React性能优化

### 内在优化

1. class组件
   + 使用`prueComponent`自动对比组件的props来达到减少渲染次数
   + 使用`shouldComponentUpdate`生命周期函数来控制是否渲染避免重复渲染
   + 当类组件实例化的时候绑定好每个方法中的this，而不是在render dom中去重复绑定this
   + 当需要`setState`的前去判断状态有没有改变，如果有改变在去调用`setState`。
   + 传递`props`只传递有用的`props`，避免`{...this.props}`这样传递。
   + 复杂组件尽量拆分小组件
   + 使用`return null`而不是css的`display`来控制节点的显示隐藏。
2. 函数组件
   + 使用memo来自动对比props来达到减少渲染次数
   + 使用`useCallback、useMemo`来缓存函数，让Hooks更具后面的依赖判断是否重新创建函数
3. 其他
   + 使用不可变的数据结构，如果Immutable.js。
   + 使用react lazy或者第三方包的loadable.js来达到组件或者页面按需加载
   + 服务端渲染react

### 外在优化

1. webpack
   + 开启code splitting
   + 打包动态链接库dll.js
   + 把dll.js放入cdn



## MVC的理解

MVC是一种架构模式。MVC模式把软件系统分为三个基本部分：

+ 模型 Model 存放应用所有的数据，数据来源可能是接口或者本地缓存等。
+ 视图 View 展示给用户的界面，可以接受用户输入。
+ 控制器 Controller 复杂连接Model和View,冲View获取输入，修改相关Model的数据后，再去通知相关View进行更新

mvvm是Model-View-ViewModel。本质就是MCV的改进版，View和Model双向绑定。



## 从输入URL到渲染出整个页面的过程包括三个部分

### 一、 DNS解析URL的过程

> DNS解析的过程就是寻找哪个服务器上有请求的资源。因为ip地址不容易记忆，一般会使用URL域名（如www.baidu.com）作为网址。DNS解析就是将域名翻译成IP地址的过程。

1. 浏览器缓存：浏览器会按照一定的频率缓存DNS记录
2. 操作系统缓存：如果浏览器中找不到需要的DNS记录，就会去操作系统中找比如windows的host文件
3. 路由器缓存：路由器也有DNS缓存
4. ISP(互联网服务提供商)的DNS服务器：ISP有专门的DNS服务器应对DNS查询请求
5. 根服务器：ISP的DNS服务器找不到之后，就会向根服务器发出请求，并进行递归查询

### 二、浏览器与服务器交互过程

1. 从上面步骤中取得IP地址，浏览器利用TCP协议通过三次握手与服务器建立连接
2. 浏览器根据TCP连接发送http的get请求报文。等待响应
3. 服务器接收到http请求之后，处理http请求报文，返回响应报文。
4. 若状态码为200,浏览器收到返回的页面，开始进行页面渲染

### 三、浏览器页面渲染过程

1. 浏览器根据深度遍历的方式把html节点遍历成dom树
2. 将css解析成cssom树
3. 将dom树和cssom树组合成render树
4. js根据得到的render树计算所有的节点在屏幕上的位置，进行布局（回流）
5. 遍历render树并调用硬件API绘制所有的节点（重绘）



## 根据从输入URL到渲染出整个页面的过程做出性能优化

### 一、网络阶段

1. 减少请求次数
   + 使用精灵图合并小图标
   + 使用字体图标
   + 合并css和js文件
   + 按需加载
   + 合理设置HTTP缓存
2. 减少单次请求所花费的时间
   + 压缩js和css文件
   + 压缩图片文件
   + 使用CDN
   + 利用浏览器缓存
   + 减少cookie传递，比如图片请求时候也会带上cookie，利用不同域名的图片服务器解决问题
   + 开启Gzip压缩传输

### 二、渲染阶段

1. 服务端渲染

2. js文件放在html的底部

3. 使用script标签的defer 和async属性优化加载方式

4. 减少dom操作，避免回流和重绘

5. 耗时的操作使用异步处理方式

6. 使用节流和防抖的功能

   

## 对闭包的理解

## 对原型链的理解

## commonjs模块和es6 module区别

## Event Loop

## Node和浏览器的Event Loop的区别

## 浏览器渲染过程

## this指向

## 对设计模式的理解

## 箭头函数与普通函数有什么不同

## 对于闭包的理解

## for in 和for of的区别

## 对前端工程的理解

前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从**模块化**、**组件化**、**规范化**、**自动化**四个方面思考。

https://www.jianshu.com/p/88ed70476adb

https://www.jianshu.com/p/0c0ea944a60a

https://www.cnblogs.com/onebox/p/9570518.html

详细见

